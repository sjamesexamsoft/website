<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>#Rust2018: A Neon Wish List ¬∑ Neon</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="‚ö†Ô∏è This article contains references to an outdated version of neon ‚ö†Ô∏è"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="#Rust2018: A Neon Wish List ¬∑ Neon"/><meta property="og:type" content="website"/><meta property="og:url" content="https://neon-bindings.com/blog/2018/01/14/rust-2018-a-neon-wish-list"/><meta property="og:description" content="‚ö†Ô∏è This article contains references to an outdated version of neon ‚ö†Ô∏è"/><meta property="og:image" content="https://neon-bindings.com/logo/text-logo.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://neon-bindings.com/logo/text-logo.svg"/><link rel="shortcut icon" href="/logo/letter-logo.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css"/><link rel="alternate" type="application/atom+xml" href="https://neon-bindings.com/blog/atom.xml" title="Neon Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://neon-bindings.com/blog/feed.xml" title="Neon Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/logo/text-logo.svg" alt="Neon"/></a><a href="/en/versions"><h3>0.2.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/intro" target="_self">Docs</a></li><li class=""><a href="https://github.com/neon-bindings/examples#table-of-contents" target="_self">Examples</a></li><li class=""><a href="/api/neon/" target="_self">API</a></li><li class=""><a href="/docs/en/learning-resources" target="_self">Resources</a></li><li class=""><a href="/docs/en/roadmap" target="_self">Roadmap</a></li><li class=""><a href="/en/help" target="_self">Help</a></li><li class="siteNavGroupActive"><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/neon-bindings/neon" target="_self">GitHub</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">Êó•Êú¨Ë™û</a></li><li><a href="/es-ES">Espa√±ol</a></li><li><a href="/fr">Fran√ßais</a></li><li><a href="/ko">ÌïúÍµ≠Ïñ¥</a></li><li><a href="/pt-BR">Portugu√™s (Brasil)</a></li><li><a href="/ru">–†—É—Å—Å–∫–∏–π</a></li><li><a href="/zh-CN">‰∏≠Êñá</a></li><li><a href="/zh-TW">ÁπÅÈ´î‰∏≠Êñá</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>‚Ä∫</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul><li class="navListItem"><a class="navItem" href="/blog/2018/10/22/hello-world">New Docs and Website! üéâüéâüéâ</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/blog/2018/01/14/rust-2018-a-neon-wish-list">#Rust2018: A Neon Wish List</a></li><li class="navListItem"><a class="navItem" href="/blog/2017/09/25/neon-wants-your-help">Neon Wants Your Help!</a></li><li class="navListItem"><a class="navItem" href="/blog/2016/04/01/native-js-classes-in-neon">Native JS Classes in Neon</a></li><li class="navListItem"><a class="navItem" href="/blog/2015/12/23/neon-node-rust">Neon: Node + Rust = üíñ</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2018/01/14/rust-2018-a-neon-wish-list">#Rust2018: A Neon Wish List</a></h1><p class="post-meta">January 14, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Dave Herman</a></p></div></header><div><span><p>‚ö†Ô∏è This article contains references to an outdated version of neon ‚ö†Ô∏è</p>
<p>While I've been thoroughly enjoying the Rust community's spirited <a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html">#Rust2018 blog-fest</a>, I wasn't really thinking of participating myself until <a href="http://jvns.ca">Julia Evans</a> pointed out <a href="https://twitter.com/b0rk/status/952370352759418880">the leadership wants to hear from everyone</a>---even if I might not have anything especially new to add. So here's my little wish list for Rust in 2018.</p>
<p>Since I'm not in Rust's leadership, I don't have to worry about synthesizing some grand narrative for the whole of Rust. So I'll just focus on a few things that would be personally useful to me. In particular, I'll stick to topics that would be helpful for my <a href="https://www.neon-bindings.com">Neon</a> project, a set of bindings for writing native Node extension modules in Rust.</p>
<!--more-->
<h1><a class="anchor" aria-hidden="true" id="stabilize-impl-trait"></a><a href="#stabilize-impl-trait" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stabilize <code>impl trait</code></h1>
<p>The most challenging part of keeping Neon's design manageable is the annotation burden. Neon provides a safe API for managing handles into Node's JavaScript garbage collector, and to do this, it requires passing around a &quot;handle scope&quot; parameter everywhere, which tracks the lifetimes of handles. There are a few flavors of handle scopes, which means helper functions in Neon projects often end up with some pretty hairy signatures:</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foo_bar</span></span>&lt;<span class="hljs-symbol">'a</span>, S: Scope&lt;<span class="hljs-symbol">'a</span>&gt;&gt;(scope: &amp;<span class="hljs-keyword">mut</span> S, obj: Handle&lt;<span class="hljs-symbol">'a</span>, JsObject&gt;) -&gt; JsResult&lt;<span class="hljs-symbol">'a</span>, JsValue&gt; {
    <span class="hljs-comment">// extract the `obj.foo` property and check that it's an object</span>
    <span class="hljs-keyword">let</span> foo = obj.get(scope, <span class="hljs-string">"foo"</span>)?.check::&lt;JsObject&gt;()?;
    <span class="hljs-comment">// extract the `obj.foo.bar` property</span>
    <span class="hljs-keyword">let</span> bar = foo.get(scope, <span class="hljs-string">"bar"</span>)?;
    <span class="hljs-literal">Ok</span>(bar)
}
</code></pre>
<p>I would love for Neon users to be able to combine lifetime elision and the <a href="https://github.com/rust-lang/rust/issues/34511"><code>impl trait</code></a> shorthand syntax to write something like:</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foo_bar</span></span>(scope: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">impl</span> Scope, obj: Handle&lt;JsObject&gt;) -&gt; JsResult&lt;JsValue&gt; {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>(With an upcoming <a href="https://github.com/dherman/rfcs-1/blob/vm-two-point-oh/text/vm-2.0.md">cleanup of the core Neon API</a>, the details of this would change a bit, but <code>impl trait</code> would be just as appealing.)</p>
<h1><a class="anchor" aria-hidden="true" id="syntactic-abstraction-for-error-propagation"></a><a href="#syntactic-abstraction-for-error-propagation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntactic abstraction for error propagation</h1>
<p>I adore the <code>?</code> syntax, but it's not enough! Expressions like <code>Ok(bar)</code> in the above example are an indication that we don't have a complete abstraction layer in the syntax for error propagation. I find it particularly galling when I have to see <code>Ok(())</code>. It's dipping down into an unnecessary abstraction layer, distracting the core logic of the function with mechanical details of the representation of Rust's control flow protocols.</p>
<p>I'm excited about the discussions around <a href="https://internals.rust-lang.org/t/pre-rfc-catching-functions/6505">&quot;catching functions&quot;</a>. I think we can get to a sweet spot where we have an abstraction layer in the syntax that never exposes the <code>Result</code> type for error handling, while still explicitly annotating every point that may throw (thanks to <code>?</code> syntax, and by contrast to exceptions). The above examples might look something like:</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_foo_bar</span></span>(scope: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">impl</span> Scope, obj: Handle&lt;JsObject&gt;) -&gt; Handle&lt;JsValue&gt; catch JsException {
    <span class="hljs-keyword">let</span> foo = obj.get(scope, <span class="hljs-string">"foo"</span>)?.check::&lt;JsObject&gt;()?;
    <span class="hljs-keyword">let</span> bar = foo.get(scope, <span class="hljs-string">"bar"</span>)?;
    <span class="hljs-keyword">return</span> bar;
}
</code></pre>
<h1><a class="anchor" aria-hidden="true" id="make-cargo-more-extensible"></a><a href="#make-cargo-more-extensible" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Make cargo more extensible</h1>
<p>Like <code>xargo</code> and <code>wargo</code>, Neon comes with a command-line tool that wraps cargo's behavior in order to abstract away a bunch of build configuration details. I'm proud of this abstraction, because it makes building native modules in Node far easier than they are with C++. But I would much rather Neon programmers could use cargo directly, calling all their usual familiar commands like <code>cargo build</code> and <code>cargo run</code>.</p>
<p>To support this, Neon will need a handful of extension points that don't exist today:</p>
<ul>
<li>The ability to extend the memoization logic with extra environmental information (e.g. which version of Node is being built for and the values of some Node-specific environment variables).</li>
<li>Post-build hooks, so I can generate the final DLL and put it in the right directory.</li>
<li>The ability to add default build flags (for example, on macOS, <code>neon build</code> actually calls <code>cargo rustc</code> with some extra low-level linking flags).</li>
<li>Project templates for <code>cargo new</code>.</li>
</ul>
<p>Being able to write</p>
<pre><code class="hljs css language-shell"><span class="hljs-meta">$</span><span class="bash"> cargo new --template=neon my-first-neon-project</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> my-first-neon-project</span>
<span class="hljs-meta">$</span><span class="bash"> cargo run</span>
</code></pre>
<p>would be so amazing.</p>
<h1><a class="anchor" aria-hidden="true" id="neon-is-about-welcoming-js-programmers"></a><a href="#neon-is-about-welcoming-js-programmers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Neon is about welcoming JS programmers</h1>
<p>I promised no narrative, but there is a common thread here. I started the Neon project because I thought it would make a great bridge between the JavaScript and Rust communities. All of the topics in this post are about facilitating that connection:</p>
<ul>
<li>Neon forces JS programmers to get more explicit about working with the garbage collector than they normally have to, so making that as lightweight as possible makes falling into native code less of a steep cliff.</li>
<li>JS is a language with exceptions, so making the protocol for emulating exceptions in Rust as ergonomic as possible will make Rust a better environment for JS programmers.</li>
<li>And just as Node projects have a workflow oriented around <code>npm</code>, giving Neon projects a standard <code>cargo</code>-based workflow will feel familiar and pleasant to Node programmers.</li>
</ul>
<p>My dream is that Neon can serve as a gateway welcoming JS programmers into Rust and systems programming for years to come. The more we smoothe the path between them, the more people we invite into our community.</p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog">Recent Posts</a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/logo/text-logo.svg" alt="Neon" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/getting-started.html">Getting Started</a><a href="/docs/en/word-counting-guide.html">Guides</a><a href="https://neon-bindings.com/api/neon/index.html" target="_blank">API Reference</a></div><div><h5>Community</h5><a href="https://rust-bindings-slackin.herokuapp.com/">Project Chat</a><a href="https://twitter.com/rustneon" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/neon-bindings/neon">GitHub</a><a class="github-button" href="https://github.com/neon-bindings/neon" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright ¬© 2018 Amila Welihinda</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'bfa6bb4b57d4fa853c0358ee9b195146',
                indexName: 'amilajack_neon',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:en","version:0.2.0"]}
              });
            </script></body></html>